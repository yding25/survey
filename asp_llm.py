# -*- coding: utf-8 -*-
"""ASP_LLM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uaNJ24FIUexcmkltHGd2--3RN58ytSvq

# Empirical study
Q1: How does performance vary with question length?

Q2: How does performance change when irrelevant information is present?

Q3: How does performance differ depending on the choice of keywords?
"""

#@title Customized parameters {display-mode: "form"} 

#@markdown Input openai key for GPT API
api_key = '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' #@param {type:"string"}

#@title Import third-party packages {display-mode: "form"}
# pip install numpy
# pip install openai==0.25.0
# from google.colab import drive
import numpy as np
import openai
import math
import os
import subprocess
import tempfile
import json
import re
import gc
import random
# from google.colab import files
import time

#@title Install asp solver {display-mode: "form"}
# git clone https://github.com/potassco/clingo.git ; cd clingo ; git submodule update --init --recursive ; mkdir -p build/release ; cd build/release ; cmake ../.. -DCMAKE_BUILD_TYPE=Release ; make

#@title Utils  {display-mode: "form"}

openai.api_key = api_key

def check_file(file):
  if os.path.exists(file):
    print('{} is generated!'.format(file))
  else:
    print('{} is not generated!'.format(file))

def asp(problem_path, result_path):
  # command = r'/content/clingo/build/release/bin/clingo /home/yan/Dropbox/survey/graph_colouring.enc.lp %s -n 0 > %s' % (problem_path, result_path)
  command = r'clingo /home/yan/Dropbox/survey/graph_colouring.enc.lp %s -n 0 > %s' % (problem_path, result_path)
  # print('command: {}'.format(command))
  subprocess.getstatusoutput(command)
  # check if exist result_path
  check_file(result_path)


def gpt3(prompt):
  gpt_model = 'text-davinci-003'
  sampling_params = {"n": 1,
                    "max_tokens": 256,
                    "temperature": 0.0,
                    "top_p": 1,
                    "logprobs": 1,
                    "presence_penalty": 0,
                    "frequency_penalty": 0,
                    "stop": ['\\n']}
  raw_response = openai.Completion.create(engine=gpt_model, prompt=prompt, **sampling_params)
  responses = [raw_response['choices'][i]['text'] for i in range(sampling_params['n'])]
  mean_probs = [math.exp(np.mean(raw_response['choices'][i]['logprobs']['token_logprobs'])) for i in range(sampling_params['n'])]
  responses = [sample.strip().lower() for sample in responses]
  return responses[0]

#@title Download ASP files {display-mode: "form"} 
# rm -r '/home/yan/Dropbox/survey'
# git clone https://github.com/yding25/survey.git

#@title Generate test.lp  {display-mode: "form"}
#@markdown Enable this module
Enable = False #@param {type:"boolean"}

if Enable:
  #@markdown Repeat M times
  M = 10 #@param {type:"integer"}

  for item in range(M):
    with open('/home/yan/Dropbox/survey/1-graph_colouring-125-0.lp', "r") as f:
      content = f.readlines()

    # get node list
    node_list = []
    for line in content:
      if line.startswith("node("):
        node_num = int(line.split("(")[1].split(")")[0])
        node_list.append(node_num)

    # sample N nodes for deletion
    #@markdown Delete N nodes
    N = 110 #@param {type:"integer"}

    nodes_to_delete = random.sample(node_list, N)
    print('nodes_to_delete: {}'.format(nodes_to_delete))

    # delete nodes
    new_content1 = []
    for line in content:
      if line.startswith("node("):
        node_num = int(line.split("(")[1].split(")")[0])
        if node_num not in nodes_to_delete:
          new_content1.append(line)
        else:
          # print('node {} is deleted!'.format(node_num))
          continue

    # delete links containing nodes
    new_content2 = []
    for line in content:
        if line.startswith("link("):
          nodes_in_link = [int(x) for x in line.split("(")[1].split(")")[0].split(",")]
          if any(node in nodes_to_delete for node in nodes_in_link):
            continue
          else:
            new_content2.append(line)

    # delete nodes
    new_content3 = []
    for line in content:
      if not line.startswith("node(") and not line.startswith("link("):
        new_content3.append(line)

    # generate new file
    current_time = int(time.time() * 100)
    filename = 'node_' + str(125 - N) + '_' + str(current_time) + '.lp'
    with open('/home/yan/Dropbox/survey/' + filename, 'w') as f:
      f.writelines(new_content1)
      f.writelines(new_content2)
      f.writelines(new_content3)
    # files.download('/home/yan/Dropbox/survey/' + filename)

#@title Solve problem using ASP {display-mode: "form"}
folder_path = '/home/yan/Dropbox/survey/nodes_12/' #@param {type:"string"}

problem_random = True #@param {type:"boolean"}
problem_files = os.listdir(folder_path)
if  problem_random:
  if problem_files:
    random_problem = random.choice(problem_files)
    problem_path = folder_path + random_problem
    print('problem path: {}'.format(problem_path))
  else:
    print('No files found in {}.'.format(folder_path))
else:
  problem = 'node_5_168297541905.lp' #@param {type:"string"}
  problem_path = folder_path + problem
  print('problem path: {}'.format(problem_path))

result_path = 'test' #@param {type:"string"}
asp(problem_path, result_path)

#@title Solve problem using GPT3 {display-mode: "form"}

# translate problem into natural language
with open(problem_path, 'r') as file:
  lines = file.read()
file.close()
nodes = re.findall(r'node\((\d+)\)\.', lines)
nodes = [x for x in nodes]
nodes = ', '.join([x for x in nodes])
prompt_node = 'The nodes are {}.'.format(nodes)

with open(problem_path, 'r') as file:
  lines = file.read()
file.close()
links = re.findall(r'link\((\d+),(\d+)\)', lines)
links = [[int(x[0]), int(x[1])] for x in links]
prompt_link = ' '.join([f'Nodes {x[0]} and {x[1]} are linked.' for x in links])

prompt_question = 'Please solve a graph coloring problem. \
The goal is to color the nodes of a graph in such a way that no two adjacent nodes have the same color.'
prompt_color = 'The colors are red0, green0, blue0, yellow0, cyan0.'
prompt_note = 'The output format is (node,color).'
prompt = prompt_question + ' ' + prompt_color + ' ' + prompt_node + ' ' + prompt_link + ' ' + prompt_note
# print('prompt: {}'.format(prompt))

response_GPT3 = gpt3(prompt)
print('response of GPT-3: \n{}'.format(response_GPT3))

#@title GPT3 vs. LLM {display-mode: "form"}
result_ASP = []
with open(result_path, 'r') as file:
  lines = file.readlines()
  for line in lines:
    if 'chosenColour' in line:
      result_ASP_temp = re.findall(r'chosenColour\((\d+),(\w+)\)', line)
      result_ASP.append([list(t) for t in result_ASP_temp])
# print('result_ASP: {}'.format(result_ASP))

result_GPT3 = re.findall(r'\((\d+), (\w+)\)', response_GPT3)
result_GPT3 = [list(t) for t in result_GPT3]
# print('result_GPT3: {}'.format(result_GPT3))

gpt3_set = set(tuple(element) for element in result_GPT3)
for group in result_ASP:
  asp_set = set(tuple(element) for element in group)
  if gpt3_set == asp_set:
    print("result_GPT3 is in result_ASP.")
    break