# -*- coding: utf-8 -*-
"""ASP_LLM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uaNJ24FIUexcmkltHGd2--3RN58ytSvq

# Empirical study
Q1: How does performance vary with question length?

Q2: How does performance change when irrelevant information is present?

Q3: How does performance differ depending on the choice of keywords?
"""

#@title Customized parameters {display-mode: "form"} 

#@markdown Input openai key for GPT API
api_key = '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' #@param {type:"string"}

#@title Import third-party packages {display-mode: "form"}
import numpy as np
import openai
import math
import os
import subprocess
import tempfile
import json
import re
import gc
import random
import time
import sys

#@title Utils  {display-mode: "form"}
openai.api_key = api_key

def check_file(file):
  if os.path.exists(file):
    print('{} is generated!'.format(file))
  else:
    print('{} is not generated!'.format(file))

def asp(problem_path, result_path):
  command = r'clingo /home/yan/Dropbox/survey/graph_colouring.enc.lp %s -n 0 > %s' % (problem_path, result_path)
  # print('command: {}'.format(command))
  subprocess.getstatusoutput(command)
  # check if exist result_path
  check_file(result_path)


def chatgpt(prompt):
  def chatgpt_basic(messages):
    gpt_model = 'gpt-3.5-turbo'
    response = openai.ChatCompletion.create(
      model=gpt_model,
      messages = messages,
      temperature=1)
    return response['choices'][0]['message']['content']
  
  messages = [{"role": "system","content":"You are a smart assistant!"}]
  try:
    d = {"role":"user","content":prompt}
    messages.append(d)
    # print('Message sent: {}'.format(messages))
    response = chatgpt_basic(messages)
    # print('response: {}'.format(response))
    return response
  except:
    print('assistant: something wrong\n')
    sys.exit()


def check_colors(links, result_ChatGPT, file_path):
  node_colors = {node: color for node, color in result_ChatGPT}
  for link in links:
    node1, node2 = link
    try:
      if node_colors[str(node1)] == node_colors[str(node2)]:
        print('nodes {} and {} have the same color.'.format(node1, node2))
        # print('nodes {} color {}; nodes {} color {}'.format(node1, node_colors[str(node1)], node2, node_colors[str(node2)]))
        file_path.write('nodes {} and {} have the same color.\n'.format(node1, node2))
        file_path.flush()
        break
    except:
      print('one of nodes {} and {} does not exist.'.format(node1, node2))
      file_path.write('one of nodes {} and {} does not exist.\n'.format(node1, node2))
      file_path.flush()
      sys.exit()


#@title Generate test.lp  {display-mode: "form"}
#@markdown Enable this module
Enable = False #@param {type:"boolean"}

if Enable:
  #@markdown Repeat M times
  M = 10 #@param {type:"integer"}

  for item in range(M):
    with open('/home/yan/Dropbox/survey/1-graph_colouring-125-0.lp', "r") as f:
      content = f.readlines()

    # get node list
    node_list = []
    for line in content:
      if line.startswith("node("):
        node_num = int(line.split("(")[1].split(")")[0])
        node_list.append(node_num)

    # sample N nodes for deletion
    #@markdown Delete N nodes
    N = 120 #@param {type:"integer"}

    nodes_to_delete = random.sample(node_list, N)
    print('nodes_to_delete: {}'.format(nodes_to_delete))

    # delete nodes
    new_content1 = []
    for line in content:
      if line.startswith("node("):
        node_num = int(line.split("(")[1].split(")")[0])
        if node_num not in nodes_to_delete:
          new_content1.append(line)
        else:
          # print('node {} is deleted!'.format(node_num))
          continue

    # delete links containing nodes
    new_content2 = []
    for line in content:
        if line.startswith("link("):
          nodes_in_link = [int(x) for x in line.split("(")[1].split(")")[0].split(",")]
          if any(node in nodes_to_delete for node in nodes_in_link):
            continue
          else:
            new_content2.append(line)

    # delete nodes
    new_content3 = []
    for line in content:
      if not line.startswith("node(") and not line.startswith("link("):
        new_content3.append(line)

    # generate new file
    current_time = int(time.time() * 100)
    filename = 'node_' + str(125 - N) + '_' + str(current_time) + '.lp'
    with open('/home/yan/Dropbox/survey/' + filename, 'w') as f:
      f.writelines(new_content1)
      f.writelines(new_content2)
      f.writelines(new_content3)

#@title Solve problem using ASP {display-mode: "form"}
folder_path = '/home/yan/Dropbox/survey/nodes_6/' #@param {type:"string"}

problem_random = True #@param {type:"boolean"}
problem_files = os.listdir(folder_path)
if  problem_random:
  if problem_files:
    random_problem = random.choice(problem_files)
    problem_path = folder_path + random_problem
    print('problem path: {}'.format(problem_path))
  else:
    print('No files found in {}.'.format(folder_path))
else:
  problem = 'node_5_168297541905.lp' #@param {type:"string"}
  problem_path = folder_path + problem
  print('problem path: {}'.format(problem_path))

Enable = False #@param {type:"boolean"}
result_path = 'test' #@param {type:"string"}

if Enable:
  asp(problem_path, result_path)

#@title Solve problem using GPT3 {display-mode: "form"}
Enable = True #@param {type:"boolean"}

if Enable:
  # translate problem into natural language
  with open(problem_path, 'r') as file:
    lines = file.read()
  file.close()
  nodes = re.findall(r'node\((\d+)\)\.', lines)
  nodes = [x for x in nodes]
  nodes = ', '.join([x for x in nodes])
  prompt_node = 'The nodes are {}.'.format(nodes)

  with open(problem_path, 'r') as file:
    lines = file.read()
  file.close()
  links = re.findall(r'link\((\d+),(\d+)\)', lines)
  links = [[int(x[0]), int(x[1])] for x in links]
  prompt_link = ' '.join([f'Nodes {x[0]} and {x[1]} are linked.'for x in links])

  prompt_question = 'Please solve a graph coloring problem. \
  The goal is to color the nodes of a graph in such a way that no two adjacent nodes have the same color.'
  prompt_color = 'The colors are red0, green0, blue0, yellow0, cyan0.'
  prompt_note = 'The output format is (node, color).'
  prompt = prompt_question + ' ' + prompt_color + ' ' + prompt_node + ' ' + prompt_link + ' ' + prompt_note
  # print('prompt: {}'.format(prompt))

  response_ChatGPT = chatgpt(prompt)
  # print('response of GPT-3: \n{}'.format(response_ChatGPT))

#@title Check result of GPT3 (solution 1) {display-mode: "form"}
Enable = False #@param {type:"boolean"}

if Enable:
  result_ASP = []
  with open(result_path, 'r') as file:
    lines = file.readlines()
    for line in lines:
      if 'chosenColour' in line:
        result_ASP_temp = re.findall(r'chosenColour\((\d+),(\w+)\)', line)
        result_ASP.append([list(t) for t in result_ASP_temp])
  # print('result_ASP: {}'.format(result_ASP))

  result_ChatGPT1 = re.findall(r'\((\d+), (\w+)\)', response_ChatGPT)
  result_ChatGPT2 = re.findall(r'\((\d+),(\w+)\)', response_ChatGPT)
  result_ChatGPT3 = re.findall(r'Node (\d+): (\w+)', response_ChatGPT)
  result_ChatGPT4 = re.findall(r'Node (\d+):(\w+)', response_ChatGPT)
  if len(result_ChatGPT1) !=0:
    result_ChatGPT = result_ChatGPT1
  elif len(result_ChatGPT2) !=0:
    result_ChatGPT = result_ChatGPT2
  elif len(result_ChatGPT3) !=0:
    result_ChatGPT = result_ChatGPT3
  elif len(result_ChatGPT4) !=0:
    result_ChatGPT = result_ChatGPT4
  else:
    print("!!!All lists are empty.")
    print('result_ChatGPT1:{} result_ChatGPT2:{} result_ChatGPT3:{} result_ChatGPT4:{}'.format(result_ChatGPT1, result_Chat))

  result_ChatGPT = [list(t) for t in result_ChatGPT]
  # print('result_ChatGPT: {}'.format(result_ChatGPT))

  gpt3_set = set(tuple(element) for element in result_ChatGPT)
  for group in result_ASP:
    asp_set = set(tuple(element) for element in group)
    if gpt3_set == asp_set:
      print("result_ChatGPT is in result_ASP.")
      break

#@title Check result of GPT3 (solution 2) {display-mode: "form"}
Enable = True #@param {type:"boolean"}

if Enable:
  result_ChatGPT = re.findall(r'\((\d+), (\w+)\)', response_ChatGPT)
  result_ChatGPT = [list(t) for t in result_ChatGPT]
  print('result_ChatGPT: {}'.format(result_ChatGPT))

file_path = open('all_results.txt', 'a')
check_colors(links, result_ChatGPT, file_path)